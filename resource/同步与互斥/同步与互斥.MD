2025/03/31 21:38
# 原子操作的实现原理与使用
    分支
        dirver_raspberry_XXXXX_vX.X.X

    文件
        ./modules/app_XXX/app_XXX.c
        ./dirverModules/dirverModules/XXX.c

# 定义

使用原子变量实现互斥
    1、原子操作
        原子变量
        原子位
    2、原子变量
    3、自旋锁
    4、信号量
    5、互斥锁

原子变量的内核操作函数
    
    原子变量的操作函数在 Linux 内核文件 sources/linux-rpi-6.6.y/include/linux/atomic.h
    原子变量类型如下，就是一个结构体 ， sources/linux-rpi-6.6.y/include/linux/types.h
    
```C

typedef struct {
    int counter;
} atomic_t

```

特殊的地方在于 操作函数，这些操作函数都是 原子 不会被打断
    atomic_read                 读出原子变量的值，即V->counter
    atomic_set                  设置原子变量的值，即V->counter = i
    atomic_add                  原子变量增加i，即V->counter += i
    atomic_sub                  原子变量减少i，即V->counter -= i
    atomic_inc                  原子变量加1，即V->counter += 1
    atomic_dec                  原子变量减1，即V->counter -= 1
    atomic_inc_and_test         原子变量 先加1，然后判断是否为0，为0则返回真，否则返回假
    atomic_dec_and_test         原子变量 先减1，然后判断是否为0，为0则返回真，否则返回假
    atomic_sub_and_test         原子变量 先减去i，然后判断是否为0，为0则返回真，否则返回假
    atomic_dec_return           原子变量 先减1，然后返回减1后的值


原子变量的内核实现
    1、atomic_read， atomic_set 这些操作都只需要一条汇编指令，所以他们本身就是不可打断的
    2、问题在于 atomic_inc 这类操作，要独处修改写回
        a、以 atomic_inc 为例，它需要三条指令，所以不能保证原子性
            #define atomic_inc(v) (atomic_add(1, v))

            atomic_add 是如何实现的呢
                1、#define ATOMIC_OPS(add, +=, add); 展开之后 得到 
                    ATOMIC_OP(add, +=, add)					\
                    ATOMIC_OP_RETURN(add, +=, add)				\
                    ATOMIC_FETCH_OP(add, +=, add)



                    ```C

                        ##op 是 add ，c_op 是 +=  #asm_op 是 add

                        // sources/linux-rpi-6.6.y/arch/arm/include/asm/atomic.h
                        #define ATOMIC_OP(op, c_op, asm_op)					\
                        static inline void arch_atomic_##op(int i, atomic_t *v)			\
                        {									\
                            unsigned long tmp;						\
                            int result;							\
                                                            \
                            prefetchw(&v->counter);						\
                            __asm__ __volatile__("@ atomic_" #op "\n"			\
                        "1:	ldrex	%0, [%3]\n"						\               // 读出 第三个参数 %3 的值，即V->counter ，读入到 %0 ，这个操作数 会指向 第 0 个地址； ldrex 是 ldreader exclusive 的缩写，即独占加载，防止其他CPU同时访问该内存地址
                        "	" #asm_op "	%0, %0, %4\n"					\           // 这个是 add 操作，把 %0 加上 %4 的值 再赋值给 %0，即V->counter += i 
                        "	strex	%1, %0, [%3]\n"						\           // 第 0 个操作数 %0 已经是新的值， 把 新的值写入 第三个参数 %3 ，即V->counter = V->counter + i； strex 是 store exclusive 的缩写，即独占存储，防止其他CPU同时访问该内存地址
                        "	teq	%1, #0\n"						\
                        "	bne	1b"							\
                            : "=&r" (result), "=&r" (tmp), "+Qo" (v->counter)		\
                            : "r" (&v->counter), "Ir" (i)					\
                            : "cc");							\
                        }


                        1、读入
                            ldrex %0 【%3】
                                1、从 %3 读入 数据到 %0,   【%3】这个 都会指向一个地址 addr ， 所以读 是 读取  addr
                                2、会把 addr 标记为 独占访问

                        2、修改


                        #define ATOMIC_OP_RETURN(op, c_op, asm_op)				\
                        static inline int arch_atomic_##op##_return_relaxed(int i, atomic_t *v)	\

                    ```


                    ```C





                        // sources/linux-rpi-6.6.y/arch/arm/include/asm/atomic.h
                        #define ATOMIC64_OP(op, op1, op2)					\
                        static inline void arch_atomic64_##op(s64 i, atomic64_t *v)		\
                        {									\
                            s64 result;							\
                            unsigned long tmp;						\
                                                            \
                            prefetchw(&v->counter);						\
                            __asm__ __volatile__("@ atomic64_" #op "\n"			\
                        "1:	ldrexd	%0, %H0, [%3]\n"					\
                        "	" #op1 " %Q0, %Q0, %Q4\n"					\
                        "	" #op2 " %R0, %R0, %R4\n"					\
                        "	strexd	%1, %0, %H0, [%3]\n"					\
                        "	teq	%1, #0\n"						\
                        "	bne	1b"							\
                            : "=&r" (result), "=&r" (tmp), "+Qo" (v->counter)		\
                            : "r" (&v->counter), "r" (i)					\
                            : "cc");							\
                        }	


                    ```

                2、#define ATOMIC_OPS(op, c_op, asm_op)					\
                    ATOMIC_OP(op, c_op, asm_op)					\
                    ATOMIC_OP_RETURN(op, c_op, asm_op)				\
                    ATOMIC_FETCH_OP(op, c_op, asm_op)


            #define atomic_add(i, v) ((void)(atomic_add_unless((v), (i), ~0UL)))
            #define atomic_add_unless(v, a, u) \
                __atomic_add_fetch((v), (a), __ATOMIC_SEQ_CST) >= (u)
        b、所以内核提供了 __sync_add_and_fetch 这个函数，它是一个原子操作，可以保证原子性
            #define atomic_inc(v) __sync_add_and_fetch((v), 1)






在内核里面实现原子变量的实现有两套机制
    1、对于小于 ARM v6 指令集 之下的 cpu ，不支持 SMP ，也不支持 多 cpu 系统，所以只需要关闭中断就可以 ，关闭 中断， Vaild++ ; 恢复中断
    2、对于 ARM v6 指令集 之上的 cpu ，可以使用特殊的指令


# 流程


# 执行顺序


# 内部机制


# Makefile
# # XXXX ---------------------
XXXX-y := $(MODULES_DIR)/XXXX/XXXX.o
obj-m := XXXX.o


# 执行命令


insmod
rmmod

chmod +x main

ps -ef | grep main
kill -9 PID

ls /proc/device-tree/
ls /sys/devices/platform/
dmesg | tail
cat /proc/devices  
cd /sys/class 



# 扩展

多个 cpu 系统，拥有 有多个中断，在程序里 关闭中断 只能 关闭当前cpu 的中断，其他cpu 还在运行

每一个变量的修改都要经历 三个步骤
    1、读取变量
    2、修改变量
    3、写入变量
