2025/03/31 12:35
# 名称
    内联汇编
        dirver_raspberry_app_assembly_v0.2.1

    文件
        ./modules/app_assembly/app_assembly.c
        ./dirverModules/my_dirver_assembly/my_dirver_assembly.c

# 定义

内联汇编
    1、在 C 函数中 使用  汇编代码
    2、使用 特殊的汇编指令 
        a、ldrex/strex 实现互斥访问
    3、也可以写一个 遵守 ATPCS 规则的汇编函数，使用C 函数去调用它


Arm 的 cpu 有两种模式
    1、arm 模式
        a、一条指令 有 4 个字节
    2、thumb 模式
        a、一条指令 有 2 个字节

# 指令集

指令集分为
    1、ARM 指令集
        1.1、ARM 指令集
        1.2、Thumb 指令集
        1.3、Thumb-2 指令集
    2、ARM64 指令集
        2.1、AArch64 指令集
        2.2、AArch32 指令集

# 流程

    使用 汇编实现 加法
        1、根据 ATPCS 规则，定义如何 使用c 调用 汇编函数 的规则；
            a、main 函数调用 add(a, b) 时 会把 第一个参数 存入 r0 ，把第二个参数 存入 r1 寄存器
        2、


放在 app_assembly_add.S 文件里
这个是 32 位的 
```S

.text           // 放在代码段
.global add     // 实现全局函数 add； global 导出一个 add 函数
.thumb           // 使用 thumb 指令集,main默认使用 thumb 指令集

add:
    add r0, r0, r1 // r0 = r0 + r1
    bx lr           // 返回 ;  bx 是跳转指令，lr 是链接寄存器，保存了函数返回地址

```

这个是64 位的

```S

.text
.global app_assembly_add

app_assembly_add:
    add x0, x0, x1  // x0 = x0 + x1 (AArch64 使用 64 位寄存器 x0, x1)
    ret             // 返回

```



# 执行顺序






# 内部机制


# Makefile
# # my_dirver_assembly 汇编 ---------------------
my_dirver_assembly-y := $(MODULES_DIR)/my_dirver_assembly/my_dirver_assembly.o $(MODULES_DIR)/my_dirver_assembly/my_asm_add.o
obj-m := my_dirver_assembly.o


# 执行命令


insmod
rmmod

chmod +x main

ps -ef | grep main
kill -9 PID

ls /proc/device-tree/
ls /sys/devices/platform/
dmesg | tail
cat /proc/devices  
cd /sys/class 



aarch64-linux-gnu-gcc -o main main.c // 编译
aarch64-linux-gnu-objdump -d main > mian.dis // 查看反汇编代码



# 扩展



如果我要在 驱动中 使用汇编

