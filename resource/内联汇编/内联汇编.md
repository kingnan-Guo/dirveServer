2025/03/31 20:12
# 名称
    内联汇编
        dirver_raspberry_app_assembly_v0.2.1

    文件
        ./modules/app_assembly/app_assembly.c
        ./dirverModules/my_dirver_assembly/my_dirver_assembly.c

# 定义

内联汇编
    1、在 C 函数中 使用  汇编代码
    2、使用 特殊的汇编指令 
        a、ldrex/strex 实现互斥访问
    3、也可以写一个 遵守 ATPCS 规则的汇编函数，使用C 函数去调用它


Arm 的 cpu 有两种模式
    1、arm 模式
        a、一条指令 有 4 个字节
    2、thumb 模式
        a、一条指令 有 2 个字节

# 指令集

指令集分为
    1、ARM 指令集
        1.1、ARM 指令集
        1.2、Thumb 指令集
        1.3、Thumb-2 指令集
    2、ARM64 指令集
        2.1、AArch64 指令集
        2.2、AArch32 指令集

# 流程

    使用 汇编实现 加法
        1、根据 ATPCS 规则，定义如何 使用c 调用 汇编函数 的规则；
            a、main 函数调用 add(a, b) 时 会把 第一个参数 存入 r0 ，把第二个参数 存入 r1 寄存器
        2、


放在 app_assembly_add.S 文件里
这个是 32 位的 
```S

.text           // 放在代码段
.global add     // 实现全局函数 add； global 导出一个 add 函数
.thumb           // 使用 thumb 指令集,main默认使用 thumb 指令集

add:
    add r0, r0, r1 // r0 = r0 + r1
    bx lr           // 返回 ;  bx 是跳转指令，lr 是链接寄存器，保存了函数返回地址

```

这个是64 位的

```S

.text
.global app_assembly_add

app_assembly_add:
    add x0, x0, x1  // x0 = x0 + x1 (AArch64 使用 64 位寄存器 x0, x1)
    ret             // 返回

```


内联汇编语法
    1、__asm__ __volatile__ ("汇编指令" : "输出操作数" : "输入操作数" : "clobbered 寄存器");
    2、__asm__ __volatile__ ("汇编指令" : "=r"(变量) : "r"(变量) : "memory");
        a、__asm__ 表示内联汇编
        b、__volatile__ 表示编译器不要优化这段代码
        c、"汇编指令" 是汇编代码
        d、"输出操作数" 是汇编指令的输出，使用 "=r"(变量) 表示将汇编指令的输出存入变量
        e、"输入操作数" 是汇编指令的输入，使用 "r"(变量) 表示将变量的值作为汇编指令的输入
        f、"clobbered 寄存器" 是汇编指令可能会修改的寄存器，使用 "cc" 表示可能会修改的条件码寄存器； 修改了哪些内容

    
    


```C




int add(int a, int b){
    int sum;
    __asm__ __volatile__ ("add %0, %1, %2" : "=r"(sum) : "r"(a), "r"(b) : "cc");
    return sum;
}


int my_inline_assembly_add2(int a, int b){
    int sum;
    // 这里 的  result value1 value2 是符号名
    __asm__ __volatile__ (
        "add %[result], %[value1], %[value2]" 
        : [result]"=r"(sum) 
        : [value1]"r"(a), [value2]"r"(b) 
        : "cc"
    );
    return sum;
}

```
    0、这里只有一条 汇编指令 add %0, %1, %2， 把 %1 和 %2 相加，结果存入 %0
    1、 %0 代表 第0个操作数 ，即 "=r"(sum)， 这个寄存器的值 最终 会更新到 sum 变量中
    2、 %1 代表 第1个操作数  "r"(a)
    3、 %2 代表 第2个操作数  "r"(b)
    4、 "=r"(sum) 表示将汇编指令的输出存入变量 sum 中
    5、 "r"(a) 表示将变量 a 的值作为汇编指令的输入
    6、 "r"(b) 表示将变量 b 的值作为汇编指令的输入
    7、 "cc" 表示可能会修改的条件码寄存器； 修改了哪些内容，cc 代表 flag 寄存器



```C
asm asm-qualifiers (AssemblerTemplate : OutputOperands  [ :  InputOperands  [ :  Clobbers ] ])

```
1、asm 关键字表示内联汇编，可以写作“__asm__”;
2、asm-qualifiers 有三个 取值
    a、__volatile__ ： 表示内联汇编的修饰符; 的意思是 易变 的、不稳定的 ，用来告诉 编译器不要随便优化这段代码，否则可能出问题;
        1、例如 ；使用 汇编指令 MOV r0, r0 ,编译器会认为 r0 没有被修改，所以会优化掉这条指令，本意是 使用这条指令用来延时，但 如果 加上 volatile 关键字，编译器就不会优化这条指令了;
    b、__inline__ ： 表示内联汇编的修饰符;
    c、__goto__ ： 表示内联汇编的修饰符;
3、AssemblerTemplate 是汇编指令模板，可以包含占位符，占位符会被后面的 OutputOperands、InputOperands 替换;

4、OutputOperands 
    a、输出操作，内联汇编执行时，输出保存在 OutputOperands 中，OutputOperands 使用冒号分隔，每个输出操作使用 "=r"(变量) 表示将汇编指令的输出存入变量;
    b、例如 ： "=r"(sum) 表示将汇编指令的输出存入变量 sum 中;

    C、[ [asmSymbolicName] ] constraint (cvariablename) 
        1、asmSymbolicName 是汇编指令模板中的占位符，是符号名；
        2、constraint 是约束条件 ： 
            常用值
                m ： memory operand 表示传入有效地址，只要cpu能支持该地址，都可以传入；
                r ： register operand 表示 寄存器操作数，使用寄存器来保存这些操作数；r(a) , a 作为 输入操作的值 传给 r 寄存器；  "=r"(sum) 的 =r 代表 寄存器 等于某一个值  register = xxx ，就 意味着 使用 = 修饰的 寄存器将会被写入 新的值
                i ： immediate operand 表示传入立即数，可以是 0-255 之间的整数；
                g ： general operand 表示传入任意类型的值，可以是寄存器、立即数、有效地址；  立即数 是 ： 
            修饰字符 
                = ： 表示内联汇编会修改这个操作数，即 写操作
                + ： 表示 这个操作数 既被读 又被写，即 读+写操作
                & ：它是一个 earlyclobber 标志 操作数，


                    earlyclobber
                        1、有些操作数在汇编代码中早早被写入了新值A，在这之后，汇编代码才去读取某个输入操作数，这个输入操作数被称为 earlyclobber
                        2、可能会有问题，假设 早早写入的新值 A ，写到 r0 寄存器，后面暑促操作数得到 数值 B，也可能 写入 r0 寄存器，这个新值 A 就会被破换掉了；
                        4、核心原因是在于输入操作数 、输入操作数 都用了一个  r0 寄存器，为什么要用 同一个 寄存器，原因是 编译器不知道你是 earlyclobber ，他以为是 先读如了所有 输出操作数，都处理完了，才去输出操作数 的，按照这个流程，没有覆盖 新值 A
                        5、如果 汇编代码中 某个 输出操作是 earlyclobber 的，它的 constraint 约束条件 就要加上 &， 这就是告诉 编译器，给 分配一个单独的寄存器，不要用同一个寄存器；

        3、cvariablename 是 C 语言中的变量名，用来保存汇编指令的输出值;
      
                
        3、variable 是变量;
        2、
        3、
5、InputOperands

6、Clobbers
    在汇编代码中 ，对于 OutputOperands 所涉及的 自存起、内存、肯定做了修改，但是 汇编代码中，也需要修改寄存器、内存 会更多，比如在计算过程中可能要用到 r3 保存临时结果，我们必须在 Clobbers 中声明 r3会被修改，告诉编译器，汇编代码中修改了哪些寄存器、内存，编译器就不会优化这些寄存器、内存了;
    b、"cc" 表示汇编代码 会修改  flags register 表示可能会修改的条件码寄存器； 修改了哪些内容，cc 代表 flag 寄存器;每种 不同架构的 cpu 架构 对应 的flags 寄存器 是不一样的；
    c、"memory" 表示 汇编代码中除了 OutputOperands 和 InputOperands 之外，还会 读写 更多内存







 "=&r"(sum) : "r"(a), "r"(b) : "cc"

 =&r 是 earlyclobber  标志 操作数，告诉编译器，给 分配一个单独的寄存器，不要用同一个寄存器；



```C

int my_inline_assembly_earlyclobber_test(int a, int b){
    int sum;

    __asm__ __volatile__ (
        "add %0, %1, %2 \n"
        "add %1, %1, #1 \n" // 寄存器 1 加 1
        "add %2, %2, #1 \n" // 寄存器 2 加 1
        // : "=&r"(sum) //  使用 "=&r" 解决  earlyclobber 问题，分配单独的寄存器 ，不复用 之前已经 用过的寄存器
        : "=r"(sum) 
        : "r"(a), "r"(b) 
        : "cc"
    );

    return sum;
}

my_inline_assembly_earlyclobber_test(8, 8)



: "=r"(sum)  编译结果  （错误）
输出 17
0000000000000bf0 <my_inline_assembly_earlyclobber_test>:
     bf0:	d10083ff 	sub	sp, sp, #0x20
     bf4:	b9000fe0 	str	w0, [sp, #12]
     bf8:	b9000be1 	str	w1, [sp, #8]
     bfc:	b9400fe0 	ldr	w0, [sp, #12]
     c00:	b9400be1 	ldr	w1, [sp, #8]
     c04:	8b010000 	add	x0, x0, x1
     c08:	91000400 	add	x0, x0, #0x1
     c0c:	91000421 	add	x1, x1, #0x1
     c10:	b9001fe0 	str	w0, [sp, #28]
     c14:	b9401fe0 	ldr	w0, [sp, #28]
     c18:	910083ff 	add	sp, sp, #0x20
     c1c:	d65f03c0 	ret


: "=r"(sum)  编译结果 
输出 16
0000000000000bf0 <my_inline_assembly_earlyclobber_test>:
     bf0:	d10083ff 	sub	sp, sp, #0x20
     bf4:	b9000fe0 	str	w0, [sp, #12]
     bf8:	b9000be1 	str	w1, [sp, #8]
     bfc:	b9400fe1 	ldr	w1, [sp, #12]
     c00:	b9400be2 	ldr	w2, [sp, #8]
     c04:	8b020020 	add	x0, x1, x2
     c08:	91000421 	add	x1, x1, #0x1
     c0c:	91000442 	add	x2, x2, #0x1
     c10:	b9001fe0 	str	w0, [sp, #28]
     c14:	b9401fe0 	ldr	w0, [sp, #28]
     c18:	910083ff 	add	sp, sp, #0x20
     c1c:	d65f03c0 	ret




```






# 执行顺序






# 内部机制


# Makefile
# # my_dirver_assembly 汇编 ---------------------
my_dirver_assembly-y := $(MODULES_DIR)/my_dirver_assembly/my_dirver_assembly.o $(MODULES_DIR)/my_dirver_assembly/my_asm_add.o
obj-m := my_dirver_assembly.o


# 执行命令


insmod
rmmod

chmod +x main

ps -ef | grep main
kill -9 PID

ls /proc/device-tree/
ls /sys/devices/platform/
dmesg | tail
cat /proc/devices  
cd /sys/class 



aarch64-linux-gnu-gcc -o main main.c // 编译
aarch64-linux-gnu-objdump -d main > mian.dis // 查看反汇编代码



# 扩展



如果我要在 驱动中 使用汇编

