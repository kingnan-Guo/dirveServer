定时器
    分支
        dirver_raspberry_interrupt_sleep_wake_up_timer_v0.1.10

    文件
        ./modules/app_interrupt_sleep_wake_up_timer/app_interrupt_sleep_wake_up_timer.c
        
        interrupt_sleep_wake_up_timer.c


定时器
    1、初始化定时器 timer_setup(&timer, timer_callback, flags);// flags的作用是 定时器是否在 进程上下文里 运行
    2、 gpio_keys[i].key_timer.expires = jiffies + XXXXX; 设置 超时时间
    3、向内核添加定时器 add_timer(&timer); 
    4、修改定时器的超时 事件 mod_timer(&timer, jiffies + XXXXX);
    5、del_timer(struct timer_list *timer) 删除定时器


定时器
    1、在按键按下的时候 ，会触发多次中断，所以 每次中断的时候 启动 定时器，延时 50ms 左右，在判断电平是否稳定，稳定后，再进行唤醒操作







```c

struct timer_list {
	struct hlist_node   ntry;
	unsigned long   expires;// 超时时间
	void    (*function)(struct timer_list *);// 超时函数
	u32 flags;

};
``
1、timer_list 是个 定时器链表， 里面放的 是一个一个的 定时器，
2、内核调用定时器 函数的 时候， 可以通过 struct timer_list * 取出 A，得到 data；老版本 里 面有个 data 的成员，新版本里，data 放到了 timer_list 的 ntry 成员里，通过 container_of() 函数，可以取出 data；





.config 的 配置
    CONFIG_TIMERFD=y
    CONFIG_HZ_1000=y
    CONFIG_HZ=100 // 每秒钟发生 100 次中断， 10ms 发生一次中断

linux 系统中 有硬件定时器， 一般每隔 10ms 发生一次中断， 就是系统 tick ，全局变量 jiffies 就会 累加 1;

当 jiffies 的值 大于 定时器的 expires 的时候， 就会 触发 定时器，调用 定时器的回调函数；




```c

struct gpio_key {
    int gpio;
    struct gpio_desc *desc; // GPIO 描述符
    int irq;                // 中断号
    int index;              // GPIO 索引
    struct timer_list key_timer;// 定时器
};

static void my_timer_expire(struct timer_list *timer){
    // 通过当前的 定时起 找到  gpio_key， 有 from_timer 函数
    struct gpio_key *key = from_timer(key, timer, key_timer);

}

```
中 使用 from_timer 从 timer_list 中取出 gpio_key；是计算 gpio_key 中 的 struct timer_list key_timer， 反推出 gpio_key 的指针