休眠唤醒
    分支
        dirver_raspberry_interrupt_sleep_wake_up_v0.1.5
使用 


步骤：
    1、初始化 wait_queue 等待队列
        wait_queue; DECLARE_WAIT_QUEUE_HEAD(wait_queue);

    2、线程休眠； 除了把程序状态改为非 RUNNING 之外，还要把线程挂到 wait_queue 等待队列上， 中断服务程序要从 wait_queue 等待队列 取出来唤醒，然后移除线程
        wait_event_interruptible(wait_queue, event);
        可中断的， 会让这个线程 进入到 TASK_INTERRUPTIBLE， 等待到 event 为 true 时，才会继续执行； 或者接收到一个信号 signal，才会继续执行，

        wait_event(wait_queue, event);
        不可中断的，会让这个线程 进入到 TASK_UNINTERRUPTIBLE 状态， 等待到 event 为 true 时，才会继续执行; 不能被信号打断

        wait_event_timeout(wait_queue, event, timeout);
        等待到 event 为 true 时，才会继续执行; 或者等待到 timeout 时，才会继续执行;

        wait_event_interruptible_timeout(wait_queue, event, timeout);
        可中断的，等待到 event 为 true 时，才会继续执行; 或者等待到 timeout 时，才会继续执行; 或者接收到一个信号 signal，才会继续执行

    3、线程唤醒
        wake_up_interruptible(&wait_queue); event = true;



    在一个系统进程里面有很多的 线程
        1、线程 挂载 链表 里面
        2、每个线程 有 一个 状态 state ，当 state 是 runing 的时候， 表明 是 可运行的
        3、当中断发生时，就会 判断 优先级最高的 进程是哪个 ，调用 schedule() 函数，切换到另外的 线程
        4、如果要 一个线程 休眠，只需要修改 state 为 sleep 或者其他非 runing 的，然后 调用 schedule() 函数，切换到另外的 线程




    中断不允许 休眠
        I2C 调用规程比较 耗时， 中间有很多休眠
    



ps -ef | grep main

 ./main /dev/my_gpio_keys_0



环形缓冲区
    分支
        dirver_raspberry_interrupt_sleep_wake_up_v0.1.6

    添加 环形缓冲区，用来存放中断数据，避免中断数据丢失
        每次存放 写入指针 +1， 每次读取 读指针 +1，当 写入指针 和 读指针 相等时，表明缓冲区已满，需要清空缓冲区，重新写入数据



