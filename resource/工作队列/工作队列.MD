2025/03/29 01:00
# 工作队列
    分支
        dirver_raspberry_interrupt_sleep_wake_up_workqueue_v0.1.12

    文件
        ./modules/app_interrupt_sleep_wake_up_workqueue/app_interrupt_sleep_wake_up_workqueue.c
        ./dirverModules/interrupt_sleep_wake_up_workqueue/interrupt_sleep_wake_up_workqueue.c

# 定义
工作队列
    1、当要处理更加复杂的 函数的时候，会比较 耗时，这些更耗时的工作放在定时器 或者 下半部中， 会使得 系统卡，并且循环等待某件事强 浪费 CPU 资源

    2、如果使用线程来处理这些耗时 的工作就可以解决系统卡顿的问题，因为线程可以 休眠
    3、在内核中，不需要自己去创建线程，可以使用 工作队列 workqueue，内核初始化工作队列 就为 它创建内核线程，我们要使用  工作队列， 只需要 把  要处理的函数 放到 工作队列中，对应的 内核线程就会取出 工作， 执行里面的函数；

    4、工作队列使用的场景， 要做的事情比较耗时，甚至要休眠，不能在定时器或者下半部中处理， 可以使用 工作队列，工作队列会使用内核线程来处理，不会卡顿

    5、工作队列是内核线程，所以工作队列的函数是运行在内核态的，不能访问用户空间的数据，只能访问内核空间的数据

    6、缺点： 多个工作函数是在某个 内核线程中 按顺序 执行的 ，前面的函数 执行的满，就会影响后面的函数，






# 流程




工作队列、内核线程 都是由 内核创建，我们只是使用，

sources/linux-rpi-6.6.y/include/linux/workqueue.h

```C
struct work_struct {
    atomic_long_t data;
    struct list_head entry;
    work_func_t func;
};


typedef void (*work_func_t)(struct work_struct *work);

```
work_func_t func; 指向 func 参数 是 （struct work_struct *work） 

1、构造一个 work_struct ，并且构造 work_struct 里面的 .func
    #define DECLARE_WORK(n, f) {
        struct work_struct n = __WORK_INITIALIZER(n, f)
    }

    #define DECLARE_DELAYED_WORK(work, fn){
        struct delayed_work work = __DELAYED_WORK_INITIALIZER(work, fn)
    }


    使用 INIT_WORK(_work, _func) 动态初始化 结构体


2、把这个 work_struct 结构体放入到 工作队列中，内核线程就会 运行 work 中的函数
    使用 schedule_work(_work) 把 work_struct 放入到 队列中，并且唤醒 内核线程，内核线程就会取出 work_struct 里面的函数 执行， 执行完后 就会 休眠，等待下一个 work_struct

    ```C

        static inline bool schedule_work(struct work_struct *work)
        {
            return queue_work(system_wq, work);
        }

    ```

    把 work 放入 默认系统 提供 的 system_wq 队列

3、



# 执行顺序


在 工作队列中

内核线程中
while(1){
    1、某个队列里 有没有 work ； 如何 判断 有没有 work ， 查看 队列中 有无 work
    2、无 work 就 休眠 sleep
    3、休眠 过程中 发现有 work 了，被唤醒； 
    4、取出 一个一个 work 去执行 work 里面的函数

}

如果一个work线程需要执行 很长的时间，需要 单独启动一个 内核线程去执行


驱动函数中
1、 构造 一个 work 还有内部的 .func 
2、使用的时候 ，把 work 放入到 队列里，并且要唤醒； 使用 scheduled_work() , 会把 work_struct 放入到队列里， 并且唤醒 内核线程
3、 唤醒内核线程后 ， 内核线程 就会 取出 work_struct 里面的函数 执行， 执行完后 就会 休眠，等待下一个 work_struct





# 内部机制











# Makefile
# # XXXX ---------------------
XXXX-y := $(MODULES_DIR)/XXXX/XXXX.o
obj-m := XXXX.o


# 执行命令


insmod
rmmod

chmod +x main

ps -ef | grep main
kill -9 PID

ls /proc/device-tree/
ls /sys/devices/platform/
dmesg | tail
cat /proc/devices  
cd /sys/class 

ps

# 扩展

[mmcqd/1] 这个是独立的内核线程， d 表示一个 守护进程； 这里是 处理 mmc 的读写。mmc 的读写比较 耗时 所以 单独 启动一个线程



```C
struct gpio_key {
    int gpio;
    struct gpio_desc *desc; // GPIO 描述符
    int irq;                // 中断号
    int index;              // GPIO 索引
    struct timer_list key_timer;// 定时器
    struct tasklet_struct key_tasklet;// tasklet 结构体
    struct work_struct key_work;// work 结构体 工作队列
};



static void my_work_func(struct work_struct *work){
    struct gpio_key *key = container_of(key, struct gpio_key, key_work);// 通过 work 找到 gpio_key
    int value = gpiod_get_value(key->desc);// 获取 GPIO 的值
    printk(KERN_INFO "%s: my_work_func on GPIO %d , value = %d\n", DEVICE_NAME, key->gpio, value);
    printk("my_work_func: the process is %s pid %d\n",current->comm, current->pid);	

}
```


使用  container_of 通过 work 找到 gpio_key， 原理是 通过 结构体 的偏移量，找到 结构体 的地址，然后通过 结构体 的地址 找到 结构体 的内容